<html>

  <head>
      <link rel=¨stylesheet¨ type=¨text/css¨ href=¨index.css¨>

      <!-- The vertex shader operates on individual vertices in our model data by setting gl_Position -->
      <script id="vertex-shader" type="x-shader/x-vertex">
      //Each point has a position and color
      attribute vec3 position;
      attribute vec4 color;

      // The transformation matrices
      uniform mat4 model;
      uniform mat4 projection;

      // Pass the color attribute down to the fragment shader
      varying vec4 vColor;

      void main() {

        // Pass the color down to the fragment shader
        vColor = color;

        // Read the multiplication in reverse order, the original point is moved
        // into clip space, and then projected into a perspective view by filling
        // in the W component
        gl_Position = projection * model * vec4( position, 1.0 );
      }
      </script>

      <!-- The fragment shader determines the color of the final pixel by setting gl_FragColor -->
      <script id="fragment-shader" type="x-shader/x-fragment">
      precision mediump float;
      varying vec4 vColor;

      void main() {
        gl_FragColor = vColor;
      }
      </script>
  </head>

  <body>
    <canvas id="canvas"></canvas>
    <script src="./shared.js"></script>
    <script src="./cube_demo_main.js"></script>
    <script>
      // Params for "MDN.computePerspectiveMatrix", see https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_model_view_projection
      var posX = 0, posY = 0, posZ = -20;
      var initScale = 5;

      var cube = new CubeDemo(
        MDN.computePerspectiveMatrix, 
        initScale, initScale, initScale,
        posX, posY, posZ 
      );

      cube.draw();
    </script>
  </body>

</html>
